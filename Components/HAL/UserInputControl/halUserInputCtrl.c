/**
  ******************************************************************************
  * @file    halUserInputCtrl.c
  * @author  MadeFactory Chief Engineer Jong-Jun Yim
  * @version V1.0.0
  * @date    24-March-2016
  * @brief   This file provides the main procedure
  ******************************************************************************
  * @attention
  *
  * MadeFactory owns the sole copyright to this software. Under international
  * copyright laws you (1) may not make a copy of this software except for
  * the purposes of maintaining a single archive copy, (2) may not derive
  * works herefrom, (3) may not distribute this work to others. These rights
  * are provided for information clarification, other restrictions of rights
  * may apply as well.
  *
  * <h2><center>&copy; Copyright 1997-2016 (c) MadeFactory Inc.</center></h2>
  ******************************************************************************
  */
/* Includes ------------------------------------------------------------------*/
#include "halUserInputCtrlAPI.h"
#include "utilExecutiveAPI.h"
#include "dvGPIOAPI.h"
#include "AK4183.h"

// ***************************************************************************
// *************** START OF PRIVATE TYPE AND SYMBOL DEFINITIONS ***************
// ***************************************************************************

#define DEF_HALUI_RELEASE_EVENT // Key Release Event
#define DEF_HALUI_INDIVIDUAL_KEY // Individual key event
// ---------------------------------------------------------------------------
// Key event condition flags
// ---------------------------------------------------------------------------
#define KEY_PRESS          (1 << 0)
#define KEY_HOLD           (1 << 1)
#define KEY_REPEAT         (1 << 2)
#define KEY_RELEASE        (1 << 3)
#define KEY_REL_AFTER      (1 << 4)

// ---------------------------------------------------------------------------
// Key event lookup table entry structure
// ---------------------------------------------------------------------------
typedef struct
{
    WORD                wKeycode;      // keycode received from input device
    WORD                wKeycodeMask;
    WORD                wKeycodeIndividual;
    BYTE                cConditions;   // bitfield of key event condition flags
    eKEY                ePressKey;     // key event generated by PRESS condition
    eKEY                eHoldKey;      // key event generated by HOLD or REPEAT condition
    eKEY                eReleaseKey;   // key event generated by RELEASE condition
    eKEY                eRelAfterKey;  // key event generated by RELEASE_AFTER condition
    BYTE                cHoldCount;    // threshold for HOLD or REPEAT event
    BYTE                cRelCount;     // threshold for RELEASE or RELEASE_AFTER event
} KEY_LOOKUP;
typedef const KEY_LOOKUP *PCKEY_LOOKUP;

//****************************************************************************
//****************** START OF PRIVATE CONFIGURATION SECTION ******************
//****************************************************************************

//--------------------------------CONFIGURATION-------------------------------
// Polling period and keycode read when no key is pressed
//--------------------------------CONFIGURATION-------------------------------
#define KEYPAD_POLL_PERIOD   100000L // 100ms (10Hz) polling rate
#define KEYPAD_NO_KEY        0x00

// These values are multipled by KEYPAD_POLL_PERIOD to determine the
// actual keypad polling time, depending on the keypad polling state.
#define KEYPAD_DEFAULT_TIME  1
#define KEYPAD_DEBOUNCE_TIME 2

//--------------------------------CONFIGURATION-------------------------------
// Polling period and max count for key repeat
//--------------------------------CONFIGURATION-------------------------------
#define KEYPAD_REPEAT_TIME   1      // polling period multiple
#define KEYPAD_REPEAT_MAX    255

//--------------------------------CONFIGURATION-------------------------------
// Polling period and touch read when touch is occurred
//--------------------------------CONFIGURATION-------------------------------
#define TOUCH_PERIOD_POLL   50000 // 50ms polling rate
#define TOUCH_PERIOD_SWIPE  250000
#define TOUCH_AXIS_GAP      10 // Unit is Pixel

//--------------------------------CONFIGURATION-------------------------------
// Key Event Look-up Table
//--------------------------------CONFIGURATION-------------------------------
static CROMDATA KEY_LOOKUP m_asKeypadEventTable[] = {
/* ----------------- BEGIN CUSTOM AREA [020] halUICtrl.c ---------------------
 * CONFIGURATION: Key event lookup table for keypad */
  {0x01, (0x0001 << 0), (0x0001 << 0), KEY_PRESS, keRAW_KEY1,  keNONE,   keNONE, keNONE, 0, 0},
  {0x02, (0x0001 << 1), (0x0001 << 1), KEY_PRESS, keRAW_KEY2,  keNONE,   keNONE, keNONE, 0, 0},
  {0x04, (0x0001 << 2), (0x0001 << 2), KEY_PRESS, keRAW_KEY3,  keNONE,   keNONE, keNONE, 0, 0},
/* ---------------------------- END CUSTOM AREA --------------------------- */
};


//****************************************************************************
//******************** START OF PRIVATE DATA DECLARATIONS ********************
//****************************************************************************
// ---------------------------------------------------------------------------
// Static data for keypad repeat key processing
// ---------------------------------------------------------------------------
static WORD             m_wLastKeypadKey;
static BYTE             m_cKeypadRptCount;

// ---------------------------------------------------------------------------
// Static data for touch event processing
// ---------------------------------------------------------------------------
static TOUCH_EVENT      m_sTouchEvent;

// ***************************************************************************
// **************** START OF PRIVATE PROCEDURE IMPLEMENTATIONS ***************
// ***************************************************************************
/**
 *  @brief      Process a key press or key hold input and write a key event to the input
                    queue if the input matches a condition in the key lookup table.
                    
 *  @param[in]  pcRptCount  : pointer to repeat key counter
                       psKeyLookup : pointer to key lookup table entry for key
                       bRepeat     : TRUE if the key is held down, FALSE otherwise
 *  @param[out] None
 *  @return     True: a meaningful key is pressed. FALSE: none key is pressed
 *  @note       None
 *  @attention  None
 */
static BYTE KeyPressProcess(PCBYTE       pcRptCount,
                            PCKEY_LOOKUP psKeyLookup,
                            BOOL         bRepeat)
{
  KEY_EVENT           sKeyEvent;

  if (bRepeat)
  {
    if (psKeyLookup->cConditions & KEY_REPEAT &&
        *pcRptCount > psKeyLookup->cHoldCount)
    {
      sKeyEvent.eKey = psKeyLookup->eHoldKey;
      sKeyEvent.cCount = *pcRptCount - psKeyLookup->cHoldCount;
      utilExecMsgSend(mqUSER_INPUT,
                      (BYTE *)&sKeyEvent);
    }
    else if (psKeyLookup->cConditions & KEY_HOLD &&
             *pcRptCount == psKeyLookup->cHoldCount)
    {
      sKeyEvent.eKey = psKeyLookup->eHoldKey;
      sKeyEvent.cCount = 0;
      utilExecMsgSend(mqUSER_INPUT,
                      (BYTE *)&sKeyEvent);
    }
  }
  else
  {
    if (psKeyLookup->cConditions & KEY_PRESS)
    {
      sKeyEvent.eKey = psKeyLookup->ePressKey;
      sKeyEvent.cCount = 0;
      utilExecMsgSend(mqUSER_INPUT,
                      (BYTE *)&sKeyEvent);
    }
  }

  return (sKeyEvent.eKey != keNONE);
}

#if defined(DEF_HALUI_RELEASE_EVENT)
/**
 *  @brief      Process a key release input and write a key event to the input queue if the
                    input matches a condition in the key lookup table.
                    
 *  @param[in]  pcRptCount  : pointer to repeat key counter
                       psKeyLookup : pointer to key lookup table entry for key
 *  @param[out] None
 *  @return     None
 *  @note       None
 *  @attention  None
 */
static void KeyReleaseProcess(PCBYTE       pcRptCount,
                              PCKEY_LOOKUP psKeyLookup)
{
  KEY_EVENT           sKeyEvent;
    
  // check for RELEASE condition
  if ((psKeyLookup->cConditions & KEY_RELEASE) &&
      (*pcRptCount <= psKeyLookup->cRelCount))
  {
    sKeyEvent.eKey = psKeyLookup->eReleaseKey;
    sKeyEvent.cCount = 0;
    utilExecMsgSend(mqUSER_INPUT,
                    (BYTE *)&sKeyEvent);
  }
  // check for RELEASE_AFTER condition
  else if ((psKeyLookup->cConditions & KEY_REL_AFTER) &&
           (*pcRptCount > psKeyLookup->cRelCount))
  {
    sKeyEvent.eKey = psKeyLookup->eRelAfterKey;
    sKeyEvent.cCount = 0;
    utilExecMsgSend(mqUSER_INPUT,
                    (BYTE *)&sKeyEvent);
  }
}
#endif


// ***************************************************************************
// ************************* START OF ISR  DEFINITIONS *************************
// ***************************************************************************

// ***************************************************************************
// ****************** START OF PUBLIC PROCEDURE DEFINITIONS ******************
// ***************************************************************************
/**
 *  @brief      This API sets up the internal state of component.
 *  @param[in]  None
 *  @param[out] None
 *  @return     None
 *  @note       None
 *  @attention  None
 */
void halUICtrlInitialize(void)
{
  m_wLastKeypadKey  = KEYPAD_NO_KEY;
  m_cKeypadRptCount = 0; 

  ZERO_STRUCTURE(m_sTouchEvent);
}

/**
 *  @brief      This API Release the internal state of component.
 *  @param[in]  None
 *  @param[out] None
 *  @return     None
 *  @note       None
 *  @attention  None
 */
void halUICtrlRelease(void)
{
  /* NONE */
}

/**
 *  @brief      This API Process the internal state of component..
 
 *  @param[in]  None
 *  @param[out] None
 *  @return     None
 *  @note       None
 *  @attention  None
 */
void halUICtrlProcess(void)
{
#if USE_TOUCH_ILI2511
  dvILI2511Process();
#endif
}

/**
 *  @brief      This API read GPIO field(s) and return assemble keycode
 *  @param      None
 *  @return     None
 *  @note       None
 *  @attention  None
 */
WORD halUICtrlKeypadCodeGet(void)
{
  WORD wKeyCode = 0;

#if USE_AMAZON_STK
  wKeyCode = (!dvGPIOFieldGet(gfGPI_KEY_1)
                  | (!dvGPIOFieldGet(gfGPI_KEY_2) << 1)
                  | (!dvGPIOFieldGet(gfGPI_KEY_3) << 2)
                  );

#else
  wKeyCode = (dvGPIOFieldGet(gfGPI_KEY_1)
                  | (dvGPIOFieldGet(gfGPI_KEY_2) << 1)
                  | (dvGPIOFieldGet(gfGPI_KEY_3) << 2)
                  );
#endif


  return wKeyCode;
  
}

/**
 *  @brief      This API handles timer events for keypad polling.
 *  @param[in]  None
 *  @param[out] None
 *  @return     None
 *  @note       None
 *  @attention  None
 */
void halUICtrlKeyEventHandler(void)
{
  BYTE                cIndex;
  WORD                wKeycode;
  BYTE                cDebounce;

/* ----------------- BEGIN CUSTOM AREA [040] halUICtrl.c ---------------------
 * Add code here to read GPIO field(s) and assemble keycode */
  wKeycode = halUICtrlKeypadCodeGet();  
/* ---------------------------- END CUSTOM AREA --------------------------- */

  cDebounce = KEYPAD_DEFAULT_TIME;
  cIndex = 0;
  if (KEYPAD_NO_KEY != wKeycode)
  {
    if (wKeycode == m_wLastKeypadKey)
    {
      if (m_cKeypadRptCount < KEYPAD_REPEAT_MAX)
      {
        m_cKeypadRptCount ++;
      }
      cDebounce = KEYPAD_REPEAT_TIME;
    }
    else
    {
      m_cKeypadRptCount = 0;
      cDebounce = KEYPAD_DEBOUNCE_TIME;
    }

    while (cIndex < (sizeof(m_asKeypadEventTable) / sizeof(KEY_LOOKUP)))
    {
#if defined(DEF_HALUI_INDIVIDUAL_KEY)
      if(m_asKeypadEventTable[cIndex].wKeycodeMask != 0xFF)
      {
        if(m_asKeypadEventTable[cIndex].wKeycodeIndividual == 
          (wKeycode & m_asKeypadEventTable[cIndex].wKeycodeMask))
        {
          KeyPressProcess(&m_cKeypadRptCount,
                          &m_asKeypadEventTable[cIndex],
                          m_cKeypadRptCount > 0);
          break;        
        }
      }
      else
#endif        
      {
        if (m_asKeypadEventTable[cIndex].wKeycode == wKeycode)
        {
          KeyPressProcess(&m_cKeypadRptCount,
                          &m_asKeypadEventTable[cIndex],
                          m_cKeypadRptCount > 0);
          break;
        }
      }

      cIndex++;
    }
  }
  else
  {
    m_cKeypadRptCount = 0;

#if defined(DEF_HALUI_RELEASE_EVENT)
    if (KEYPAD_NO_KEY != m_wLastKeypadKey)
    {
      while (cIndex <
             (sizeof(m_asKeypadEventTable) / sizeof(KEY_LOOKUP)))
      {
        if (m_asKeypadEventTable[cIndex].wKeycode == m_wLastKeypadKey)
        {
          KeyReleaseProcess(&m_cKeypadRptCount,
                            &m_asKeypadEventTable[cIndex]);
          break;
        }

        cIndex++;
      }
    }
#endif        
  }

  m_wLastKeypadKey = wKeycode;

  // set up next keypad poll timer event
  utilExecCounterSet(coHAL_UI_KEY, uS_TO_TICKS(KEYPAD_POLL_PERIOD) * cDebounce);
}

/**
 *  @brief      This API Gets the Touch Axis
 *  @param[in]  None
 *  @param[out] psTouchEvent: Pointer to return back Touch Event
 *  @return     TRUE if Event Occurred, else Event is not occurred
 *  @note       None
 *  @attention  None
 */
BOOL halUICtrlTouchEventGet(PTOUCH_EVENT psTouchEvent)
{
  ASSERT(psTouchEvent != NULL);

  *psTouchEvent = m_sTouchEvent;

  return (m_sTouchEvent.wEventFlags) ? TRUE : FALSE;
}

/**
 *  @brief      This API handles Touch events
 *  @param[in]  None
 *  @param[out] None
 *  @return     None
 *  @note       None
 *  @attention  None
 */
void halUICtrlTouchEventHandler(void)
{
  DWORD dwNextEventPeriod = TOUCH_PERIOD_POLL;

#if USE_TOUCH_AK4183 /* Polling */  
  AK4183_READ_STATUS sStatusTouch = 
    {
      .bEventOccurred = FALSE, 
    };  

  /* Read Touch Status */
  dvAK4183TouchGet(0, NULL);
  sStatusTouch = dvAK4183ReadStatusGet(0);    
#elif USE_TOUCH_ILI2511 /* Interrupt driven */
  ILITP_STATUS_TOUCH sStatusTouch = 
    {
      .bEventOccurred = FALSE, 
    };  

  /* Read Touch Status */
  sStatusTouch = dvILITPStatusTouchGet();
#elif USE_TOUCH_ST1912
#elif USE_TOUCH_AR1010
#else
#error "BSP Version Need to Define"
#endif

  /* Process Touch Event */
  if(sStatusTouch.bEventOccurred)
  {   
    if(m_sTouchEvent.wEventFlags == TOUCH_NONE) /* START */
    {
      m_sTouchEvent.sPoint = sStatusTouch.sPoint;
      m_sTouchEvent.wEventFlags = TOUCH_PRESS;
      //dwNextEventPeriod = 100000;
      /// msgDbg("TOUCH_PRESS");
    }    
    else if(m_sTouchEvent.wEventFlags & (TOUCH_PRESS | TOUCH_HOLD) /* HOLD */
      && (INT)sStatusTouch.sPoint.wX <= ((INT)m_sTouchEvent.sPoint.wX + TOUCH_AXIS_GAP)
      && (INT)sStatusTouch.sPoint.wX >= ((INT)m_sTouchEvent.sPoint.wX - TOUCH_AXIS_GAP)
      && (INT)sStatusTouch.sPoint.wY <= ((INT)m_sTouchEvent.sPoint.wY + TOUCH_AXIS_GAP)
      && (INT)sStatusTouch.sPoint.wY >= ((INT)m_sTouchEvent.sPoint.wY - TOUCH_AXIS_GAP))
    {
      m_sTouchEvent.wEventFlags |= TOUCH_HOLD;
      m_sTouchEvent.wEventLevel += 1;
      //dwNextEventPeriod = 300000;
      /// msgDbg("TOUCH_HOLD");

      utilExecMsgSend(mqUSER_TOUCH,
                      (PBYTE)&m_sTouchEvent);      
    }  
    else /* SWIPE */
    {
      if(m_sTouchEvent.wEventFlags & (TOUCH_PRESS | TOUCH_HOLD)) /* SWIPE START */
      {
        m_sTouchEvent.wEventFlags = TOUCH_SWIPE_START; // Anything to start just
        m_sTouchEvent.wEventLevel = 0;
        ///dwNextEventPeriod = TOUCH_PERIOD_SWIPE;
        /// msgDbg("TOUCH_SWIPE START");
      }
      else if(m_sTouchEvent.wEventFlags 
              & ( TOUCH_SWIPE_START
                | TOUCH_SWIPE_RIGHT 
                | TOUCH_SWIPE_LEFT)) /* SWIPE LEVEL CALCULATE */
      {
        if(sStatusTouch.sPoint.wX > m_sTouchEvent.sPoint.wX)
        {
          m_sTouchEvent.wEventFlags = TOUCH_SWIPE_RIGHT;
          m_sTouchEvent.wEventLevel = (sStatusTouch.sPoint.wX -  m_sTouchEvent.sPoint.wX) 
                                        / TOUCH_AXIS_GAP;
          /// msgDbg("TOUCH_SWIPE_RIGHT: %d", m_sTouchEvent.wEventLevel);
        }
        else if(sStatusTouch.sPoint.wX < m_sTouchEvent.sPoint.wX)
        {
          m_sTouchEvent.wEventFlags = TOUCH_SWIPE_LEFT;
          m_sTouchEvent.wEventLevel = (m_sTouchEvent.sPoint.wX -  sStatusTouch.sPoint.wX) 
                                        / TOUCH_AXIS_GAP; 
          /// msgDbg("TOUCH_SWIPE_LEFT: %d", m_sTouchEvent.wEventLevel);
        }
        else
        {
          m_sTouchEvent.wEventLevel = 0;
          /// msgDbg("TOUCH_SWIPE_X: 0");
        }
        
        utilExecMsgSend(mqUSER_TOUCH,
                      (PBYTE)&m_sTouchEvent);
        ///dwNextEventPeriod = TOUCH_PERIOD_SWIPE;
        
      }
      else
      { 
        ZERO_STRUCTURE(m_sTouchEvent);
        dwNextEventPeriod = 0;
      }
    }
  }
  else
  {
    if(m_sTouchEvent.wEventFlags & (TOUCH_PRESS | TOUCH_HOLD))
    {
      m_sTouchEvent.wEventFlags = TOUCH_TAP_SIGNLE;
      //dwNextEventPeriod = 200000;
      /// msgDbg("TOUCH_TAP_SIGNLE");
      utilExecMsgSend(mqUSER_TOUCH,
                      (PBYTE)&m_sTouchEvent);
      ZERO_STRUCTURE(m_sTouchEvent);
      dwNextEventPeriod = 0;
    }
    
    if(m_sTouchEvent.wEventFlags & TOUCH_SWIPE_START)
    {
      m_sTouchEvent.wEventFlags = TOUCH_TAP_SIGNLE;
      /// msgDbg("TOUCH_TAP_SIGNLE:2");
      utilExecMsgSend(mqUSER_TOUCH,
                      (PBYTE)&m_sTouchEvent);
      ZERO_STRUCTURE(m_sTouchEvent);
      dwNextEventPeriod = 0;      
    }    
    else /* Clear Touch Event */
    {
      ZERO_STRUCTURE(m_sTouchEvent);
      dwNextEventPeriod = 0;
    }
  }  

  if(dwNextEventPeriod)
    utilExecCounterSet(coHAL_UI_TOUCH, uS_TO_TICKS(dwNextEventPeriod));  

}




